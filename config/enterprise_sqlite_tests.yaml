# Enhanced SQLite Examples with data_type Feature
# Demonstrates explicit semantic data type specification for enterprise-style database schemas

tests:
  # Example 1: Enterprise customer database with cryptic column names
  - question_id: 401
    samples: 2
    template: "Query the database {{artifacts}}/{{qs_id}}/{{entity1}}.db and find the total salary for all Engineering department employees. Reply only with the total."
    scoring_type: "stringmatch"
    expected_response: "{{sqlite_query:SELECT SUM(SAL_AMT) FROM enterprise_employees WHERE DEPT_CD = 'Engineering':TARGET_FILE}}"
    sandbox_setup:
      type: "create_sqlite"
      target_file: "{{artifacts}}/{{qs_id}}/{{entity1}}.db"
      content:
        table_name: "enterprise_employees"
        columns:
          - {name: "EMP_ID", type: "auto_id"}
          - {name: "EMP_NM", type: "TEXT", data_type: "person_name"}
          - {name: "DEPT_CD", type: "TEXT", data_type: "department"}
          - {name: "SAL_AMT", type: "INTEGER", data_type: "salary"}
          - {name: "STAT_FLG", type: "TEXT", data_type: "status"}
        rows: 50

  # Example 2: Financial transactions with special character column names
  - question_id: 402
    samples: 2
    template: "What is the average transaction amount for completed transactions in {{artifacts}}/{{qs_id}}/{{entity1}}.db?"
    scoring_type: "stringmatch"
    expected_response: "{{sqlite_query:SELECT AVG($AMT) FROM financial_txns WHERE STATUS# = 'completed':TARGET_FILE}}"
    sandbox_setup:
      type: "create_sqlite"
      target_file: "{{artifacts}}/{{qs_id}}/{{entity1}}.db"
      content:
        table_name: "financial_txns"
        columns:
          - {name: "TXN#", type: "auto_id"}
          - {name: "CUST@", type: "TEXT", data_type: "person_name"}
          - {name: "$AMT", type: "INTEGER", data_type: "currency"}
          - {name: "STATUS#", type: "TEXT", data_type: "status"}
          - {name: "PROC_DT", type: "TEXT", data_type: "date"}
        rows: 100

  # Example 3: Multi-table enterprise system with foreign keys
  - question_id: 403
    samples: 2
    template: "How many orders above 50000 are there from customers in the Engineering department in {{artifacts}}/{{qs_id}}/{{entity1}}.db?"
    scoring_type: "stringmatch"
    expected_response: "{{sqlite_query:SELECT COUNT(*) FROM enterprise_orders o JOIN enterprise_customers c ON o.CUST_REF = c.CUST_ID WHERE c.DEPT_CD = 'Engineering' AND o.ORD_AMT > 50000:TARGET_FILE}}"
    sandbox_setup:
      type: "create_sqlite"
      target_file: "{{artifacts}}/{{qs_id}}/{{entity1}}.db"
      content:
        tables:
          - name: "enterprise_customers"
            columns:
              - {name: "CUST_ID", type: "auto_id"}
              - {name: "CUST_NM", type: "TEXT", data_type: "person_name"}
              - {name: "DEPT_CD", type: "TEXT", data_type: "department"}
              - {name: "LOC_CD", type: "TEXT", data_type: "region"}
            rows: 20
          - name: "enterprise_orders"
            columns:
              - {name: "ORD_ID", type: "auto_id"}
              - {name: "CUST_REF", type: "INTEGER", foreign_key: "enterprise_customers.CUST_ID"}
              - {name: "ORD_AMT", type: "INTEGER", data_type: "currency"}
              - {name: "STAT_CD", type: "TEXT", data_type: "status"}
            rows: 75

  # Example 4: Legacy system export with abbreviated names
  - question_id: 404
    samples: 2
    template: "Create a JSON report at {{artifacts}}/{{qs_id}}/{{entity1}}/report.json with the name and region of the first customer from {{artifacts}}/{{qs_id}}/{{entity1}}.db."
    scoring_type: "readfile_jsonmatch"
    file_to_read: "{{artifacts}}/{{qs_id}}/{{entity1}}/report.json"
    expected_content: '{"customer": "{{sqlite_query:SELECT CUST_NM FROM legacy_customers LIMIT 1:TARGET_FILE}}", "region": "{{sqlite_query:SELECT RGN_CD FROM legacy_customers LIMIT 1:TARGET_FILE}}"}'
    sandbox_setup:
      type: "create_sqlite"
      target_file: "{{artifacts}}/{{qs_id}}/{{entity1}}.db"
      content:
        table_name: "legacy_customers"
        columns:
          - {name: "ID", type: "auto_id"}
          - {name: "CUST_NM", type: "TEXT", data_type: "person_name"}
          - {name: "RGN_CD", type: "TEXT", data_type: "region"}
          - {name: "ACTV_FLG", type: "TEXT", data_type: "status"}
        rows: 25

  # Example 5: Mixed explicit and implicit column definitions
  - question_id: 405
    samples: 2
    template: "What is the total value of all products in category 'Electronics' from {{artifacts}}/{{qs_id}}/{{entity1}}.db?"
    scoring_type: "stringmatch"
    expected_response: "{{sqlite_query:SELECT SUM(VAL_AMT) FROM mixed_products WHERE category = 'Electronics':TARGET_FILE}}"
    sandbox_setup:
      type: "create_sqlite"
      target_file: "{{artifacts}}/{{qs_id}}/{{entity1}}.db"
      content:
        table_name: "mixed_products"
        columns:
          - {name: "PROD_ID", type: "INTEGER", data_type: "id"}      # Explicit
          - {name: "product_name", type: "TEXT"}                     # Implicit (clear name)
          - {name: "VAL_AMT", type: "INTEGER", data_type: "currency"} # Explicit
          - {name: "category", type: "TEXT"}                         # Implicit (clear name)
          - {name: "AVAIL_QTY", type: "INTEGER", data_type: "id"}    # Explicit (quantity as ID type)
        rows: 80

  # Example 6: Inventory system with product relationships
  - question_id: 406
    samples: 2
    template: "Find the average price of products that have stock above 50 units in {{artifacts}}/{{qs_id}}/{{entity1}}.db."
    scoring_type: "stringmatch"
    expected_response: "{{sqlite_query:SELECT AVG(PRC_USD) FROM inventory_items WHERE QTY_AVAIL > 50:TARGET_FILE}}"
    sandbox_setup:
      type: "create_sqlite"
      target_file: "{{artifacts}}/{{qs_id}}/{{entity1}}.db"
      content:
        table_name: "inventory_items"
        columns:
          - {name: "ITEM_CD", type: "TEXT", data_type: "id"}
          - {name: "ITEM_DESC", type: "TEXT", data_type: "product"}
          - {name: "PRC_USD", type: "INTEGER", data_type: "price"}
          - {name: "QTY_AVAIL", type: "INTEGER", data_type: "id"}
          - {name: "CAT_CD", type: "TEXT", data_type: "category"}
        rows: 120

  # Example 7: HR system with employment data
  - question_id: 407
    samples: 2
    template: "How many employees in the Sales department have more than 5 years of experience in {{artifacts}}/{{qs_id}}/{{entity1}}.db?"
    scoring_type: "stringmatch"
    expected_response: "{{sqlite_query:SELECT COUNT(*) FROM hr_employees WHERE DEPT_NM = 'Sales' AND YRS_EXP > 5:TARGET_FILE}}"
    sandbox_setup:
      type: "create_sqlite"
      target_file: "{{artifacts}}/{{qs_id}}/{{entity1}}.db"
      content:
        table_name: "hr_employees"
        columns:
          - {name: "EMP_NUM", type: "INTEGER", data_type: "id"}
          - {name: "FULL_NM", type: "TEXT", data_type: "person_name"}
          - {name: "DEPT_NM", type: "TEXT", data_type: "department"}
          - {name: "YRS_EXP", type: "INTEGER", data_type: "experience"}
          - {name: "HIRE_DT", type: "TEXT", data_type: "date"}
        rows: 150

  # Example 8: Compare implicit vs explicit data generation
  - question_id: 408
    samples: 1
    template: "This test demonstrates the difference between implicit and explicit data type generation in SQLite."
    scoring_type: "stringmatch"
    expected_response: "comparison complete"
    sandbox_setup:
      type: "create_sqlite"
      target_file: "{{artifacts}}/{{qs_id}}/{{entity1}}.db"
      content:
        tables:
          - name: "implicit_data"
            columns:
              - {name: "id", type: "auto_id"}
              - {name: "customer", type: "TEXT"}        # Would generate lorem words
              - {name: "amount", type: "INTEGER"}       # Would use name hints
            rows: 5
          - name: "explicit_data"
            columns:
              - {name: "CUST_ID", type: "INTEGER", data_type: "id"}
              - {name: "CUST_REF", type: "TEXT", data_type: "person_name"}
              - {name: "AMT_VAL", type: "INTEGER", data_type: "currency"}
            rows: 5
